---
title: パート 2 - アーキテクチャ
description: このドキュメントでは、クロスプラットフォームアプリケーションの構築に役立つアーキテクチャパターンについて説明します。 一般的なアプリケーションレイヤー (データレイヤー、データアクセスレイヤーなど) と一般的なモバイルソフトウェアパターン (MVVM、MVC など) について説明します。
ms.prod: xamarin
ms.assetid: 2176DB2D-E84A-3757-CFAB-04A586068D50
author: davidortinau
ms.author: daortin
ms.date: 03/27/2017
ms.openlocfilehash: 84a06e23ec7125892701762ab5bad7b86a8faf90
ms.sourcegitcommit: 2fbe4932a319af4ebc829f65eb1fb1816ba305d3
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/29/2019
ms.locfileid: "73030265"
---
# <a name="part-2---architecture"></a>パート 2 - アーキテクチャ

クロスプラットフォームアプリを構築するための重要な理念は、プラットフォーム間でのコード共有を最大に活用できるアーキテクチャを作成することです。 次のオブジェクト指向プログラミングの原則に従うことで、適切に設計されたアプリケーションを構築できます。

- **カプセル化**–クラスおよびアーキテクチャレイヤーが、必要な関数を実行する最小限の API のみを公開し、実装の詳細を非表示にすることを保証します。 クラスレベルでは、オブジェクトは "ブラックボックス" として動作し、コードを使用することはタスクの実行方法を認識する必要がないことを意味します。 アーキテクチャレベルでは、より抽象的なレイヤーのコードに代わってより複雑な相互作用を調整する、単純化された API を奨励するファサードのようなパターンを実装することを意味します。 つまり、UI コード (など) は画面の表示とユーザー入力の受け入れだけを行う必要があります。また、データベースと直接対話することはありません。 同様に、データアクセスコードはデータベースの読み取りと書き込みのみを行いますが、ボタンやラベルと直接対話することはできません。
- **役割の分離**–各コンポーネント (アーキテクチャとクラスレベルの両方) に明確で明確に定義された目的があることを確認します。 各コンポーネントは、定義されたタスクだけを実行し、その機能を使用する必要がある他のクラスからアクセスできる API を介してその機能を公開する必要があります。
- **ポリモーフィズム**–複数の実装をサポートするインターフェイス (または抽象クラス) をプログラミングすることは、プラットフォーム固有の機能を使用しながら、プラットフォーム間でコアコードを記述して共有できることを意味します。

自然な結果は、個別の論理レイヤーを持つ実際のエンティティまたは抽象エンティティの後にモデル化されたアプリケーションです。 コードをレイヤーに分割することで、アプリケーションの理解、テスト、および保守が容易になります。 各レイヤーのコードを物理的に分離することをお勧めします (ディレクトリ内でも、非常に大規模なアプリケーションの場合は別個のプロジェクトでもかまいません)。また、(名前空間を使用して) 論理的に分離することをお勧めします。

 <a name="Typical_Application_Layers" />

## <a name="typical-application-layers"></a>一般的なアプリケーションレイヤー

このドキュメント全体とケーススタディでは、次の6つのアプリケーションレイヤーを参照しています。

- **データレイヤー** –非揮発性データの永続性。これは SQLite データベースである可能性がありますが、XML ファイルやその他の適切なメカニズムを使用して実装できます。
- **データアクセス層**–実装の詳細を呼び出し元に公開することなく、データへの作成、読み取り、更新、削除 (CRUD) アクセスを提供するデータレイヤーのラッパーです。 たとえば、DAL には、データを照会または更新するための SQL ステートメントが含まれている場合がありますが、参照しているコードはこのことを認識する必要はありません。
- ビジネス**層**– (ビジネスロジック層または BLL と呼ばれることもあります) には、ビジネスエンティティ定義 (モデル) とビジネスロジックが含まれています。 ビジネスファサードパターンの候補。
- **サービスアクセス層**–クラウド内のサービスにアクセスするために使用されます。複雑な web サービス (REST、JSON、WCF) から、リモートサーバーからのデータとイメージの取得を簡単に行うことができます。 ネットワーク動作をカプセル化し、アプリケーション層と UI 層で使用される単純な API を提供します。
- **アプリケーションレイヤー** –通常はプラットフォーム固有のコードです (通常はプラットフォーム間で共有されません)。または、アプリケーション固有のコードです (通常は再利用できません)。 アプリケーションレイヤーと UI レイヤーのどちらにコードを配置するかについては、(a) を使用して、クラスに実際の表示コントロールがあるかどうか、または (b) 複数の画面またはデバイス間で共有されているかどうかを判断することをお勧めします (例として、 iPhone と iPad)。
- **ユーザーインターフェイス (UI) レイヤー** –ユーザー向けのレイヤーで、画面、ウィジェット、およびそれらを管理するコントローラーが含まれています。

アプリケーションには、必ずしもすべてのレイヤーが含まれているとは限りません。たとえば、ネットワークリソースにアクセスしないアプリケーションには、サービスアクセス層が存在しません。 非常に単純なアプリケーションは、非常に基本的な操作なので、データ層とデータアクセス層をマージすることがあります。

 <a name="Common_Mobile_Software_Patterns" />

## <a name="common-mobile-software-patterns"></a>一般的なモバイルソフトウェアパターン

パターンは、定期的な解決策を一般的な問題に取り込むための確立された方法です。 保守が容易でわかりやすいモバイルアプリケーションを構築する際に役立つ重要なパターンがいくつかあります。

- **モデル、ビュー、ビューモデル (MVVM)** –モデルビュービューモデルパターンは、Xamarin. フォームなどのデータバインディングをサポートするフレームワークでよく使用されます。 Windows Presentation Foundation (WPF) や Silverlight などの XAML 対応の Sdk によっており世されました。ビューモデルは、データバインディングとコマンドを使用して、データ (モデル) とユーザーインターフェイス (ビュー) 間の移動として機能します。
- **モデル、ビュー、コントローラー (MVC)** –一般的で誤解の多いパターン。 mvc は、ユーザーインターフェイスを構築するときに最もよく使用され、UI 画面の実際の定義 (ビュー) を分離するために使用されます。これは、操作を処理するエンジン (コントローラー) とそれにデータを設定するデータ (モデル)。 モデルは実際には完全に省略可能な部分であるため、このパターンを理解するための中核となるのがビューとコントローラーです。 MVC は、iOS アプリケーションの一般的なアプローチです。
- **ビジネスファサード**–マネージャーパターンとも呼ばれ、複雑な作業のための簡単なエントリポイントを提供します。 たとえば、タスク追跡アプリケーションでは、`GetAllTasks()`、`GetTask(taskID)`、`SaveTask (task)` などのメソッドを含む `TaskManager` クラスがある場合があります。`TaskManager` クラスを使用すると、タスクオブジェクトの実際の保存/取得の内部動作にファサードを提供できます。
- **シングルトン**–シングルトンパターンは、特定のオブジェクトの1つのインスタンスのみが存在できるようにするために用意されています。 たとえば、モバイルアプリケーションで SQLite を使用する場合、データベースのインスタンスは1つしか必要ありません。 シングルトンパターンを使用することは、これを保証するための簡単な方法です。
- **プロバイダー** – SILVERLIGHT、WPF、および WinForms アプリケーション間でコードを再利用することを奨励するために、Microsoft によって造語された (戦略、または基本的な依存関係の挿入とほぼ同じ) パターン。 共有コードは、インターフェイスまたは抽象クラスに対して記述できます。また、コードが使用されるときに、プラットフォーム固有の具象実装が記述され、渡されます。
- **Async – async**キーワードと混同しないでください。非同期パターンは、実行時間の長い作業を UI または現在の処理を保持せずに実行する必要がある場合に使用されます。 最も単純な形式では、非同期パターンは、現在のスレッドがバックグラウンドプロセスからの応答を処理してリッスンしている間に、長時間実行されるタスクを別のスレッド (またはタスクなどの同様のスレッドの抽象化) で開始する必要があることを単純に記述します。データとまたは状態が返されたときに UI を更新します。

各パターンの詳細については、「ケーススタディ」で実際の使用法を示しています。 Wikipedia では、 [MVVM](https://en.wikipedia.org/wiki/Model–view–viewmodel)、 [MVC](https://en.wikipedia.org/wiki/Model–view–controller)、[ファサード](https://en.wikipedia.org/wiki/Facade_pattern)、[シングルトン](https://en.wikipedia.org/wiki/Singleton_pattern)、[戦略](https://en.wikipedia.org/wiki/Strategy_pattern)、および[プロバイダー](https://en.wikipedia.org/wiki/Provider_model)のパターン (および[設計パターン](https://en.wikipedia.org/wiki/Design_Patterns)の一般的なパターン) についてより詳細に説明しています。
