---
title: パート 4 - 複数のプラットフォームを処理する
description: このドキュメントでは、プラットフォームまたは機能に基づいてアプリケーションの相違を処理する方法について説明します。 画面のサイズ、ナビゲーションのメタファ、タッチとジェスチャ、プッシュ通知、およびリストやタブなどのインターフェイスのパラダイムについて説明します。
ms.prod: xamarin
ms.assetid: BBE47BA8-78BC-6A2B-63BA-D1A45CB1D3A5
author: conceptdev
ms.author: crdun
ms.date: 03/23/2017
ms.openlocfilehash: fb01d0ca56365fa95aa563ca99394dea39dc7d31
ms.sourcegitcommit: 933de144d1fbe7d412e49b743839cae4bfcac439
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 09/04/2019
ms.locfileid: "70288880"
---
# <a name="part-4---dealing-with-multiple-platforms"></a>パート 4 - 複数のプラットフォームを処理する

## <a name="handling-platform-divergence-amp-features"></a>プラットフォームの相違&amp;点の処理

相違点は、"クロスプラットフォーム" の問題ではありません。' 同じ ' プラットフォームのデバイスには、さまざまな機能があります (特に、利用可能なさまざまな Android デバイス)。 最も明白で基本的なのは画面サイズですが、その他のデバイス属性は異なる可能性があり、アプリケーションは特定の機能を確認し、存在 (または不要) に応じて動作を変える必要があります。

これは、すべてのアプリケーションが機能の正常な低下を処理する必要があることを意味します。それ以外の場合は、魅力的の最低公分母となる特徴セットを提示する必要があります。 Xamarin の各プラットフォームのネイティブ Sdk との緊密な統合により、アプリケーションはプラットフォーム固有の機能を利用できるようになるため、これらの機能を使用するようにアプリを設計するのが理にかなっています。

プラットフォームの機能の違いの概要については、プラットフォーム機能のドキュメントを参照してください。

## <a name="examples-of-platform-divergence"></a>プラットフォームの相違の例

### <a name="fundamental-elements-that-exist-across-platforms"></a>プラットフォーム間に存在する基本的な要素

一般的なモバイルアプリケーションには、いくつかの特性があります。
これらは、一般的にすべてのデバイスに当てはまる上位レベルの概念であり、アプリケーションの設計の基礎を形成します。

- タブまたはメニューを使用した機能の選択
- データの一覧とスクロール
- データの1つのビュー
- データの1つのビューを編集する
- 元に戻す

高レベルの画面フローを設計するときは、これらの概念について一般的なユーザーエクスペリエンスを基本にすることができます。

### <a name="platform-specific-attributes"></a>プラットフォーム固有の属性

すべてのプラットフォームに存在する基本的な要素に加えて、設計の主要なプラットフォームの違いに対処する必要があります。 これらの違いについて考慮する必要がある場合があります。

- **画面サイズ**–一部のプラットフォーム (iOS およびそれ以前の Windows Phone バージョンなど) には、ターゲットが比較的単純な標準化された画面サイズがあります。 Android デバイスには、さまざまな画面の寸法があり、アプリケーションでのサポートにより多くの労力を必要とします。
- **ナビゲーションメタファ**: プラットフォーム間で異なります (例: ハードウェアの [戻る] ボタン、パノラマ UI コントロール)、およびプラットフォーム (Android 2 および4、iPhone vs iPad) 内。
- **キーボード**–一部の Android デバイスは、物理的なキーボードを備えていますが、他のデバイスにはソフトウェアキーボードしかありません。 ソフトキーボードが画面の一部に隠されていることを検出するコードは、これらの違いに敏感である必要があります。
- **タッチとジェスチャ**-ジェスチャ認識のオペレーティングシステムのサポートは、特に各オペレーティングシステムの以前のバージョンで異なります。 以前のバージョンの Android では、タッチ操作のサポートが非常に制限されています。つまり、古いデバイスのサポートには別のコードが必要になることがあります
- **プッシュ通知**–各プラットフォームにはさまざまな機能/実装があります (例: Windows 上のライブタイル)。

### <a name="device-specific-features"></a>デバイス固有の機能

アプリケーションに必要な最小限の機能を決定します。または、では、各プラットフォームで利用できる追加機能を決定します。 機能を検出して機能を無効にしたり、代替手段を提供したりするには、コードが必要です ( 地理的な場所の代わりに、ユーザーが場所を入力したり、マップから選択したりできるようにすることができます。

- **カメラ**–デバイスによって機能が異なります。デバイスによっては、カメラが搭載されていないデバイスや、前面と背面に接続しているカメラがあります。 カメラによっては、ビデオ記録が可能です。
- **地理的な場所 & マップ**– GPS または wi-fi の場所のサポートは、すべてのデバイスに存在しません。 また、アプリは、各方法でサポートされているさまざまな精度レベルを満たす必要があります。
- **加速度計、ジャイロスコープ、コンパス**–これらの機能は、各プラットフォーム上の選択されたデバイスでのみ検出されることが多いため、ほとんどの場合、アプリケーションはハードウェアがサポートされていないときにフォールバックを提供する必要があります。
- **Twitter と Facebook** -IOS5 と iOS6 では、それぞれ ' 組み込み ' のみです。 以前のバージョンおよびその他のプラットフォームでは、独自の認証関数とインターフェイスを各サービスの API に直接提供する必要があります。
- **近距離無線通信 (NFC)** – (一部の) Android フォンのみ (書き込み時)。

## <a name="dealing-with-platform-divergence"></a>プラットフォームの相違点の処理

同じコードベースから複数のプラットフォームをサポートするための2つの方法があり、それぞれに独自の利点と欠点があります。

- **プラットフォームの抽象化**–ビジネスファサードパターンは、プラットフォーム間の統一されたアクセスを提供し、特定のプラットフォームの実装を1つの統合された API に抽象化します。
- **異なるの実装**–インターフェイス、継承、条件付きコンパイルなどのアーキテクチャツールを使用して、異なる実装を介して特定のプラットフォーム機能を呼び出します。

## <a name="platform-abstraction"></a>プラットフォームの抽象化

### <a name="class-abstraction"></a>クラスの抽象化

共有コードで定義されているインターフェイスまたは基本クラスを使用して、プラットフォーム固有のプロジェクトで実装または拡張します。 クラス抽象化を使用した共有コードの記述と拡張は、特にポータブルクラスライブラリに適しています。これは、使用可能なフレームワークのサブセットが限られており、プラットフォーム固有のコード分岐をサポートするコンパイラディレクティブを含めることができないためです。

#### <a name="interfaces"></a>インターフェイス

インターフェイスを使用すると、共通コードを活用するために共有ライブラリに渡すことができるプラットフォーム固有のクラスを実装できます。

インターフェイスは共有コードで定義され、パラメーターまたはプロパティとして共有ライブラリに渡されます。

その後、プラットフォーム固有のアプリケーションはインターフェイスを実装し、共有コードを利用して "処理" できます。

 **長所**

実装にはプラットフォーム固有のコードを含めることができ、プラットフォーム固有の外部ライブラリを参照することもできます。

 **短所**

実装を作成し、共有コードに渡す必要があります。 インターフェイスが共有コード内で深く使用されている場合は、複数のメソッドパラメーターを通じて渡されるか、または呼び出しチェーンを介してプッシュされます。 共有コードが多数の異なるインターフェイスを使用している場合は、共有コード内のどこかに作成して設定する必要があります。

#### <a name="inheritance"></a>継承

共有コードは、1つまたは複数のプラットフォーム固有のプロジェクトで拡張できる抽象クラスまたは仮想クラスを実装できます。 これは、インターフェイスの使用に似ていますが、いくつかの動作が既に実装されています。 インターフェイスと継承のどちらを使用するかについては、さまざまな観点からC#見てみましょう。特に、1つの継承のみが許可されているため、api の設計を進めることができます。 継承は慎重に使用してください。

インターフェイスの長所と短所は、継承にも同様に適用されます。基底クラスに実装コード (場合によっては、必要に応じて拡張可能なプラットフォームに依存しない実装全体) を含めることができるという利点もあります。

## <a name="xamarinforms"></a>Xamarin.Forms

[Xamarin](~/get-started/index.yml)のドキュメントを参照してください。

### <a name="other-cross-platform-libraries"></a>その他のクロスプラットフォームライブラリ

これらのライブラリは、開発者向けのC#クロスプラットフォーム機能も提供します。

- [**Xamarin. Essentials**](~/essentials/index.md) –共通機能のクロスプラットフォーム api。
- [**SkiaSharp**](~/xamarin-forms/user-interface/graphics/skiasharp/index.md) –クロスプラットフォームの2d グラフィックス。

## <a name="conditional-compilation"></a>条件付きコンパイル

場合によっては、共有コードが各プラットフォームで異なる動作をする必要があり、動作が異なるクラスや機能にアクセスすることもあります。 条件付きコンパイルは、異なるシンボルが定義されている複数のプロジェクトで同じソースファイルが参照されている共有アセットプロジェクトで最適に機能します。

Xamarin プロジェクトでは`__MOBILE__` 、iOS と Android の両方のアプリケーションプロジェクトに対して true が定義されています (これらのシンボルについては、2つのアンダースコアの前と後の修正後に注意してください)。

```csharp
#if __MOBILE__
// Xamarin iOS or Android-specific code
#endif
```

#### <a name="ios"></a>iOS

Xamarin ios は、 `__IOS__` ios デバイスを検出するために使用できるものを定義します。

```csharp
#if __IOS__
// iOS-specific code
#endif
```

また、ウォッチ式と TV 固有のシンボルもあります。

```csharp
#if __TVOS__
// tv-specific stuff
#endif

#if __WATCHOS__
// watch-specific stuff
#endif
```

#### <a name="android"></a>Android

Xamarin Android アプリケーションにのみコンパイルする必要があるコードは、次のものを使用できます。

```csharp
#if __ANDROID__
// Android-specific code
#endif
```

各 API バージョンでも新しいコンパイラディレクティブが定義されているため、このようなコードを使用すると、新しい Api が対象となっている場合に機能を追加できます。 各 API レベルには、"lower" レベルのシンボルがすべて含まれています。 この機能は、複数のプラットフォームをサポートする場合にはあまり役に立ちません。通常、 `__ANDROID__`シンボルは十分です。

```csharp
#if __ANDROID_11__
// code that should only run on Android 3.0 Honeycomb or newer
#endif
```

#### <a name="mac"></a>Mac

現時点では、Xamarin. Mac 用の組み込みシンボルはありませんが、**シンボルの定義** ボックスで コンパイラの定義 を **> >** して独自のシンボルを追加したり、.csproj ファイルを編集して`__MAC__`そこに追加したりすることができます (たとえば、) **。**

```xml
<PropertyGroup><DefineConstants>__MAC__;$(DefineConstants)</DefineConstants></PropertyGroup>
```

#### <a name="universal-windows-platform-uwp"></a>ユニバーサル Windows プラットフォーム (UWP)

`WINDOWS_UWP` を使用してください。 Xamarin プラットフォームシンボルのような文字列を囲むアンダースコアはありません。

```csharp
#if WINDOWS_UWP
// UWP-specific code
#endif
```

#### <a name="using-conditional-compilation"></a>条件付きコンパイルの使用

条件付きコンパイルの単純なケーススタディ例では、SQLite データベースファイルのファイルの場所を設定します。 この3つのプラットフォームには、ファイルの場所を指定するための要件が若干異なります。

- **iOS** – Apple では、ユーザー以外のデータを特定の場所 (ライブラリディレクトリ) に配置することが推奨されていますが、このディレクトリにシステム定数はありません。 正しいパスを構築するには、プラットフォーム固有のコードが必要です。
- **Android** –によって`Environment.SpecialFolder.Personal`返されるシステムパスは、データベースファイルを格納するのに許容される場所です。
- **Windows Phone** -分離ストレージメカニズムでは、完全パスを指定することはできません。相対パスとファイル名だけを指定します。
- **ユニバーサル Windows プラットフォーム**– api `Windows.Storage`を使用します。

次のコードでは、条件付きコンパイル`DatabaseFilePath`を使用して、が各プラットフォームに対して正しいことを確認します。

```csharp
public static string DatabaseFilePath {
        get {
    var filename = "TodoDatabase.db3";
#if SILVERLIGHT
    // Windows Phone 8
    var path = filename;
#else

#if __ANDROID__
    string libraryPath = Environment.GetFolderPath(Environment.SpecialFolder.Personal); ;
#else
#if __IOS__
        // we need to put in /Library/ on iOS5.1 to meet Apple's iCloud terms
        // (they don't want non-user-generated data in Documents)
        string documentsPath = Environment.GetFolderPath (Environment.SpecialFolder.Personal); // Documents folder
        string libraryPath = Path.Combine (documentsPath, "..", "Library");
#else
        // UWP
        string libraryPath = Windows.Storage.ApplicationData.Current.LocalFolder.Path;
#endif
#endif
        var path = Path.Combine (libraryPath, filename);
#endif
        return path;
}
```

結果として、すべてのプラットフォームで作成および使用できるクラスが生成され、SQLite データベースファイルが各プラットフォームの別の場所に配置されます。
