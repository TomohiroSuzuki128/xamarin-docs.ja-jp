---
title: xib でのコード生成
description: このドキュメントでは、xib ファイルをにマップするためのコードをC#生成する方法について説明します。これにより、プログラムでビジュアルコントロールにアクセスできるようになります。
ms.prod: xamarin
ms.assetid: 365991A8-E07A-0420-D28E-BC4D32065E1A
ms.technology: xamarin-ios
author: davidortinau
ms.author: daortin
ms.date: 03/21/2017
ms.openlocfilehash: 778b8eeb82ebfb62cfb8c16e14f341c9afb8ff7a
ms.sourcegitcommit: 2fbe4932a319af4ebc829f65eb1fb1816ba305d3
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/29/2019
ms.locfileid: "73022250"
---
# <a name="xib-code-generation-in-xamarinios"></a>xib でのコード生成

> [!IMPORTANT]
> このドキュメントでは、Xamarin Designer for iOS でアクションとアウトレットが使用されていないため、Visual Studio for Mac と Xcode の Interface Builder のみとの統合について説明します。 IOS Designer の詳細については、 [Ios designer](~/ios/user-interface/designer/index.md)のドキュメントを参照してください。

Apple Interface Builder ツール ("IB") を使用すると、ユーザーインターフェイスを視覚的にデザインできます。 IB によって作成されたインターフェイス定義は、 **xib**ファイルに保存されます。 **Xib**ファイル内のウィジェットとその他のオブジェクトには、"クラス id" を与えることができます。これは、カスタムのユーザー定義型にすることができます。 これにより、ウィジェットの動作をカスタマイズしたり、カスタムウィジェットを作成したりすることができます。

これらのユーザークラスは、通常、UI コントローラークラスのサブクラスです。 インターフェイスオブジェクトに接続できる*アウトレット*(プロパティに似ています) と*アクション*(イベントに似ています) があります。 実行時に、IB ファイルが読み込まれると、オブジェクトが作成され、コンセントとアクションがさまざまな UI オブジェクトに動的に接続されます。 これらのマネージクラスを定義するときは、IB が想定しているものと一致するように、すべてのアクションとアウトレットを定義する必要があります。 Visual Studio for Mac は、分離コードに似たモデルを使用してこれを簡略化します。 これは、Xcode での目的に似ていますが、コード生成モデルと規則は、.NET 開発者にとって馴染み深いものになるように調整されています。

**Xib**ファイルの操作は、現在、Xamarin. IOS For Visual Studio ではサポートされていません。

## <a name="xib-files-and-custom-classes"></a>xib ファイルとカスタムクラス

Cocoa Touch の既存の型を使用するだけでなく、 **xib**ファイルでカスタム型を定義することもできます。 また、 **xib**ファイルで定義されている型を使用したり、コードで純粋にC#定義したりすることもできます。 現在、Interface Builder は、 **xib**ファイルの外部で定義されている型の詳細を認識していません。そのため、このファイルの一覧表示やカスタムのアウトレットとアクションの表示は行われません。 この制限を解除することは将来に予定されています。

カスタムクラスは、Interface Builder の [クラス] タブの [サブクラスの追加] コマンドを使用して、 **xib**ファイルで定義できます。 これらは "分離コード" クラスと呼ばれています。 **Xib**ファイルにプロジェクト内の "xib.designer.cs" というファイルが含まれている場合、Visual Studio for Mac は、 **xib**内のすべてのカスタムクラスの部分クラス定義を自動的に入力します。 これらの部分クラスを "デザイナークラス" と呼びます。

## <a name="generating-code"></a>コードの生成

*ページ*のビルドアクションを含む **{0}xib**ファイルの場合、xib.designer.cs ファイルがプロジェクトにも存在{0}する場合、Visual Studio for Mac によって、ファイルに含まれるすべてのユーザークラスの部分クラスが生成されます。**xib ファイル。** すべてのアクションのアウトレットと部分メソッドのプロパティが含まれています。 このファイルが存在するだけで、コード生成が有効になります。

**Xib**ファイルが変更されると、デザイナーファイルが自動的に更新され、Visual Studio for Mac がフォーカスを取り戻す。 デザイナーファイルを手動で変更することはできません。変更は、次回 Visual Studio for Mac によってファイルが更新されるときに上書きされます。

## <a name="registration-and-namespaces"></a>登録と名前空間

Visual Studio for Mac は、標準の .NET プロジェクト namespacing と一貫性を持たせるために、デザイナーファイルの場所にプロジェクトの既定の名前空間を使用してデザイナークラスを生成します。 デザイナーファイルの名前空間は、プロジェクトの "既定の名前空間" と ".NET 名前付けポリシー" の設定によって決まります。 プロジェクトの既定の名前空間が変更された場合は、MD によって新しい名前空間のクラスが再生成されるため、一部のクラスが一致しなくなる可能性があることに注意してください。

クラスを目的の C ランタイムが検出できるようにするために、Visual Studio for Mac はクラスに `[Register (name)]` 属性を適用します。 Xamarin iOS では `NSObject`派生クラスが自動的に登録されますが、完全修飾された .NET 名が使用されます。 Visual Studio for Mac によって適用される属性は、各クラスが**xib**ファイルで使用されている名前に登録されるようにオーバーライドします。 Visual Studio for Mac を使用してデザイナーファイルを生成せずに、IB でカスタムクラスを使用する場合、マネージクラスが期待される目標 C クラス名と一致するようにするには、これを手動で適用する必要がある場合があります。

クラスを複数の**xib**に定義することはできません。または、競合することもあります。

## <a name="non-designer-class-parts"></a>非デザイナークラスの部分

デザイナー部分クラスは、そのように使用するためのものではありません。 アウトレットはプライベートであり、基底クラスは指定されていません。 各クラスは、対応する "非デザイナー" クラスパーツを別のファイルに含めることが想定されています。これは、基底クラスを設定し、アウトレットを使用または公開し、xib の読み込み時にネイティブコードからクラスをインスタンス化するために必要なコンストラクターを定義し**ます。** . **Xib**テンプレートはこれを行いますが、 **xib**で定義する追加のカスタムクラスについては、非デザイナーパーツを手動で追加する必要があります。

その理由は、柔軟性が必要なためです。 たとえば、複数の分離コードクラスは、クラスを IB でサブクラス化する共通のマネージ抽象クラスをサブクラス化できます。

Xib.designer.cs デザイナーファイルの **{0}** 横にある**xib.cs ファイル{0}** にこれらを配置するのは従来の方法です。

<a name="generated" />

## <a name="generated-actions-and-outlets"></a>生成されたアクションとアウトレット

部分デザイナークラスでは、Visual Studio for Mac は IB で定義されているすべての接続されたアウトレットに対応するプロパティと、接続されたアクションに対応する部分メソッドを生成します。

### <a name="outlet-properties"></a>アウトレットのプロパティ

デザイナークラスには、カスタムクラスで定義されているすべてのアウトレットに対応するプロパティが含まれています。 これらはプロパティであるため、遅延バインディングを有効にするために、Xamarin. iOS から目標 C のブリッジまでの実装の詳細を示します。 これらは、CodeBehind クラスからのみ使用することを意図したプライベートフィールドに相当するものとして考慮する必要があります。 パブリックにする場合は、他のプライベートフィールドの場合と同様に、アクセサープロパティを非デザイナークラス部分に追加します。

アウトレットのプロパティが `id` の型を持つように定義されている場合 (`NSObject`と等価)、デザイナーのコードジェネレーターは、そのアウトレットに接続されているオブジェクトに基づいて、可能な限り強力な型を決定します。
ただし、これは将来のバージョンではサポートされない可能性があるため、カスタムクラスを定義するときは、明示的にアウトレットを厳密に指定することをお勧めします。

### <a name="action-properties"></a>アクションのプロパティ

デザイナークラスには、カスタムクラスで定義されているすべてのアクションに対応する部分メソッドが含まれています。 これらは、実装のないメソッドです。 部分メソッドの目的は次のとおりです。

1. 非デザイナークラスパーツのクラス本体に `partial` を入力した場合、Visual Studio for Mac は、実装されていないすべての部分メソッドのシグネチャをオートコンプリートに提供します。
2. 部分メソッドシグネチャには、それらを目的の C 言語に公開する属性が適用されているので、対応するアクションとして処理できます。

必要に応じて、部分メソッドを無視し、別のメソッドに属性を適用することによってアクションを実装するか、基底クラスにフォールスルーすることができます。

アクションが `id` の送信元の種類 (`NSObject`に相当) を持つように定義されている場合、デザイナーコードジェネレーターは、そのアクションに接続されているオブジェクトに基づいて、最も強力な型を決定します。 ただし、これは将来のバージョンではサポートされない可能性があるため、カスタムクラスを定義するときには、明示的にアクションを厳密に指定することをお勧めします。

これらの部分メソッドは、に対してC#のみ作成されることに注意してください。 CodeDOM は部分メソッドをサポートしないため、他の言語では生成されません。

## <a name="cross-xib-class-usage"></a>クロス XIB クラスの使用法

場合によっては、ユーザーが複数の**xib**ファイルから同じクラスを参照することが必要になることがあります。たとえば、タブコントローラーを使用します。 これを行うには、別の**xib**ファイルからクラス定義を明示的に参照するか、 **xib**で同じクラス名をもう一度定義します。

後者の場合は、 **xib**ファイルを個別に Visual Studio for Mac ため、問題が発生する可能性があります。 重複する定義を自動的に検出してマージすることはできません。そのため、同じ部分クラスが複数のデザイナーファイルで定義されている場合は、レジスタ属性を複数回適用する競合が発生する可能性があります。 最新バージョンの Visual Studio for Mac はこの問題を解決しようとしますが、必ずしも期待どおりに動作するとは限りません。 今後、このはサポートされなくなる可能性があり、Visual Studio for Mac その代わりに、 **xib**ファイルおよびプロジェクト内のマネージコードで定義されているすべての型が、すべての**xib**ファイルから直接表示されるようになります。

## <a name="type-resolution"></a>型の解決

IB で使用される型は、目標 C 型の名前です。 これらは、レジスタ属性を使用して CLR 型にマップされます。 アウトレットとアクションコードを生成すると、Visual Studio for Mac は、Xamarin. iOS core によってラップされたすべての目的 C の型の対応する CLR 型を解決し、型名を完全修飾します。

ただし、コードジェネレーターは、現在、ユーザーコードまたはライブラリ内の目的 C の型名から CLR 型を解決できないため、このような場合は型名を逐語的に出力します。 これは、対応する CLR 型は、目的の C 型と同じ名前を持ち、それを使用しているコードと同じ名前空間にある必要があることを意味します。 これは、コードの生成時にプロジェクト内のすべての目的 C の型を考慮することによって、将来修正される予定です。
