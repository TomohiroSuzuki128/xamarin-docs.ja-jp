---
ms.openlocfilehash: b505f4a4f7a8f50a6044d01a327eef76a7b1ce3b
ms.sourcegitcommit: b0ea451e18504e6267b896732dd26df64ddfa843
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/13/2020
ms.locfileid: "70758047"
---
|プロパティ|説明|オプション|
|--- |--- |--- |
|`abi.type`|**ABI の種類** &ndash; エミュレートされたデバイスの ABI (アプリケーション バイナリ インターフェイス) の種類を指定します。 **x86** オプションは、一般に "x86" または "IA-32" と呼ばれる命令セット用です。 **x86_64** オプションは、64 ビットの x86 命令セット用です。 **armeabi-v7a** オプションは、v7-a ARM 拡張機能を持つ ARM 命令セット用です。 **arm64-v8a** オプションは、AArch64 をサポートする ARM 命令セット用です。|x86、x86_64、armeabi-v7a、arm64-v8a|
|`disk.cachePartition`|**キャッシュ パーティション** &ndash; エミュレートされたデバイスがそのデバイス上で **/cache** パーティションを使用するかどうかを判別します。 **/cache** パーティション (最初は空) は、頻繁にアクセスされるデータとアプリ コンポーネントが Android によって格納される場所です。 **no** に設定されている場合、エミュレーターは **/cache** パーティションを使用せず、その他の `disk.cache` 設定は無視されます。|yes、no|
|`disk.cachePartition.path`|**キャッシュ パーティション パス** &ndash; 開発用コンピューター上にあるキャッシュ パーティション イメージ ファイルを指定します。 エミュレーターは、 **/cache** パーティションに対してこのファイルを使用します。 エミュレーターの data ディレクトリへの絶対パスまたは相対パスを入力します。 設定されていない場合、エミュレーターによって、開発用コンピューター上に **cache.img** という空の一時ファイルが作成されます。 ファイルが存在しない場合は、空のファイルとして作成されます。 `disk.cachePartition` を **no** に設定している場合はこのオプションは無視されます。||
|`disk.cachePartition.size`|**キャッシュ パーティション サイズ** &ndash; キャッシュ パーティション ファイルのサイズ (バイト単位)。 通常は、既定のキャッシュ サイズである 66 メガバイトを超える非常に大きなファイルをアプリがダウンロードする場合を除き、このオプションを設定する必要はありません。 `disk.cachePartition` を **no** に設定している場合はこのオプションは無視されます。 この値が整数の場合は、バイト単位でサイズが指定されます。 値に **K**、**M**、**G** を追加することで、キロバイト、メガバイト、ギガバイト単位でサイズを指定することもできます。 最小サイズは **9 M** で、最大サイズは **1023 G** です。||
|`disk.dataPartition.initPath`|**データ パーティションへの最初のパス** &ndash; データ パーティションの初期コンテンツを指定します。 ユーザー データをワイプした後、エミュレーターは、初期バージョンとして **userdata.img** を使用する代わりに、指定したファイルの内容をユーザー データ (既定では **userdata-qemu.img**) にコピーします。||
|`disk.dataPartition.path`|**データ パーティションへのパス** &ndash; ユーザー データ パーティション ファイルを指定します。 永続的なユーザー データ ファイルを構成するには、開発コンピューターでファイル名とパスを入力します。 ファイルが存在しない場合、エミュレーターは既定のファイル **userdata.img** からイメージを作成し、`disk.dataPartition.path` で指定されたファイル名で格納し、エミュレーターがシャットダウンしたときにユーザー データをそこで保持します。 パスを指定しない場合、既定のファイルは **userdata-qemu.img** という名前になります。 特殊な値 **\<temp>** を指定すると、エミュレーターは一時ファイルを作成して使用します。 `disk.dataPartition.initPath` を設定すると、ブート時にその内容が `disk.dataPartition.path` ファイルにコピーされます。 このオプションを空白のままにすることはできないことに注意してください。||
|`disk.dataPartition.size`|**データ パーティション サイズ** &ndash; ユーザー データ パーティションのサイズをバイト単位で指定します。 この値が整数の場合は、バイト単位でサイズが指定されます。 値に **K**、**M**、**G** を追加することで、キロバイト、メガバイト、ギガバイト単位でサイズを指定することもできます。 最小サイズは **9 M** で、最大サイズは **1023 G** です。||
|`disk.ramdisk.path`|**ramdisk パス** &ndash; ブート パーティション (ramdisk) イメージへのパス。 ramdisk イメージは、システム イメージがマウントされる前にカーネルによって読み込まれるシステム イメージのサブセットです。 通常、ramdisk イメージには、起動時のバイナリと初期化スクリプトが含まれます。 このオプションが指定されていない場合、既定値はエミュレーターのシステム ディレクトリの **ramdisk.img** となります。||
|`disk.snapStorage.path`|**スナップショットの記憶域パス** &ndash; すべてのスナップショットが格納されるスナップショットの記憶域ファイルへのパス。 実行中に作成されたスナップショットはすべてこのファイルに保存されます。 エミュレーターの実行中に復元できるのは、このファイルに保存されているスナップショットのみです。 このオプションが指定されていない場合、既定値はエミュレーターのデータ ディレクトリにある snapshots.img となります。||
|`disk.systemPartition.initPath`|**システム パーティションの init パス** &ndash; システム イメージ ファイルの読み取り専用コピーへのパス。具体的には、API レベルおよびすべてのバリアントに対応するシステム ライブラリとデータを含むパーティションです。 このパスが指定されていない場合、既定値はエミュレーターのシステム ディレクトリにある system.img となります。||
|`disk.systemPartition.path`|**システム パーティション パス** &ndash; 読み取り/書き込みのシステム パーティション イメージへのパス。 このパスが設定されていない場合、`disk.systemPartition.initPath` で指定されたファイルの内容から一時ファイルが作成されて初期化されます。||
|`disk.systemPartition.size`|**システム パーティション サイズ** &ndash; システム パーティションに最適なサイズ (バイト単位)。 実際のシステム パーティション イメージがこの設定よりも大きい場合、サイズは無視されます。それ以外の場合は、システム パーティション ファイルを拡大できる最大サイズが指定されます。 この値が整数の場合は、バイト単位でサイズが指定されます。 値に **K**、**M**、**G** を追加することで、キロバイト、メガバイト、ギガバイト単位でサイズを指定することもできます。 最小サイズは **9 M** で、最大サイズは **1023 G** です。||
|`hw.accelerometer`|**加速度計** &ndash; エミュレートされたデバイスに加速度計センサーが含まれるかどうかを判別します。 加速度計は、デバイスが (自動回転で使用される) 向きを判別するのに役立ちます。 加速度計は、3 つのセンサー軸に沿ってデバイスのアクセラレーションを報告します。|yes、no|
|`hw.audioInput`|**オーディオ録音サポート** &ndash; エミュレートされたデバイスでオーディオを録音できるかどうかを判別します。|yes、no|
|`hw.audioOutput`|**オーディオ再生サポート** &ndash; エミュレートされたデバイスでオーディオを再生できるかどうかを判別します。|yes、no|
|`hw.battery`|**バッテリ サポート** &ndash; エミュレートされたデバイスがバッテリで作動できるかどうかを判別します。|yes、no|
|`hw.camera`|**カメラ サポート** &ndash; エミュレートされたデバイスにカメラがあるかどうかを判別します。|yes、no|
|`hw.camera.back`|**背面カメラ** &ndash; 背面カメラ (レンズがユーザーとは逆の方を向いている) を構成します。 開発用コンピューターで Web カメラを使用して、エミュレートされたデバイスでの背面カメラをシミュレートする場合は、この値を webcam*n* に設定する必要があります。この _n_ で Web カメラを選択します (Web カメラが 1 つのみの場合は、**webcam0** を選択します)。 emulated に設定した場合、エミュレーターはソフトウェアでカメラをシミュレートします。 背面カメラを無効にするには、この値を none に設定します。 背面カメラを有効にする場合は、必ず `hw.camera` も有効にしてください。|emulated、none、webcam0|
|`hw.camera.front`|**前面カメラ** &ndash; 前面カメラ (レンズがユーザーの方を向いている) を構成します。 開発用コンピューターで Web カメラを使用して、エミュレートされたデバイスでの前面カメラをシミュレートする場合は、この値を webcam*n* に設定する必要があります。この _n_ で Web カメラを選択します (Web カメラが 1 つのみの場合は、**webcam0** を選択します)。 emulated に設定した場合、エミュレーターはソフトウェアでカメラをシミュレートします。 前面カメラを無効にするには、この値を設定 none に設定します。 前面カメラを有効にする場合は、必ず `hw.camera` も有効にしてください。|emulated、none、webcam0|
|`hw.camera.maxHorizontalPixels`|**カメラの水平方向の最大ピクセル数** &ndash; エミュレートされたデバイスのカメラの最大水平解像度 (ピクセル単位) を構成します。||
|`hw.camera.maxVerticalPixels`|**カメラの垂直方向の最大ピクセル数** &ndash; エミュレートされたデバイスのカメラの最大垂直解像度 (ピクセル単位) を構成します。||
|`hw.cpu.arch`|**CPU アーキテクチャ** &ndash; 仮想デバイスでエミュレートされる CPU アーキテクチャ。 ハードウェア アクセラレータとして Intel HAXM を使用している場合は、32 ビット CPU の **x86** を選択します。 HAXM のアクセラレーションを使用している 64 ビットのデバイスに対しては **x86_64** を選択します。 (必ず、SDK Manager で対応する Intel x86 システム イメージをインストールしてください。例: Intel x86 Atom または Intel x86 Atom_64。)ARM CPU をシミュレートするには、**arm** (32 ビットの場合) または **arm64** (64 ビットの ARM CPU の場合) を選択します。 ARM ではハードウェア アクセラレータを使用できないため、ARM ベースの仮想デバイスは x86 ベースのものよりかなり遅く実行されることに留意してください。|x86、x86_64、arm、arm64|
|`hw.cpu.model`|**CPU モデル** &ndash; 通常、この値は未設定のままです (明示的に設定されていない場合、`hw.cpu.arch` から派生した値に設定されます)。 ただし、実験用にエミュレーター固有の文字列に設定することはできます。||
|`hw.dPad`|**DPad キー** &ndash; エミュレートされたデバイスが方向パッド (DPad) キーをサポートするかどうかを判別します。 通常、DPad には方向制御を示す 4 つのキーがあります。|yes、no|
|`hw.gps`|**GPS サポート** &ndash; エミュレートされたデバイスに GPS (Global Positioning System) 受信機があるかどうかを判別します。|yes、no|
|`hw.gpu.enabled`|**GPU エミュレーション** &ndash; エミュレートされたデバイスが GPU エミュレーションをサポートするかどうかを判別します。 有効な場合、GPU エミュレーションでは、画面上で 2D と 3D の両方のグラフィックをレンダリングするために OpenGL ES (Open GL for Embedded Systems) を使用し、関連付けられている GPU エミュレーション モード設定で GPU エミュレーションの実装方法を決定します。|yes、no|
|`hw.gpu.mode`|**GPU エミュレーション モード** &ndash; エミュレーターで GPU エミュレーションを実装する方法を決定します。 auto を選択した場合、エミュレーターは、開発用コンピューターの設定に基づいて、ハードウェアとソフトウェアのアクセラレータを選択します。 host を選択した場合、エミュレーターは、開発用コンピューターのグラフィック プロセッサを使用して、高速レンダリングのために GPU エミュレーションを実行します。 GPU がエミュレーターと互換性がなく、Windows で作業している場合は、host の代わりに angle を試すことができます。 angle モードの場合、DirectX を使用して、host と同様のパフォーマンスが提供されます。 mesa を選択した場合、エミュレーターは Mesa 3D ソフトウェア ライブラリを使用して、グラフィックをレンダリングします。 開発用コンピューターのグラフィック プロセッサでのレンダリングに問題がある場合は、mesa を選択してください。 コンピューターの GPU を使用する場合よりパフォーマンスが若干低いソフトウェアでグラフィックをレンダリングする場合は、swiftshader モードを使用できます。 off オプション (グラフィック ハードウェア エミュレーションを無効にする) は非推奨のオプションです。このオプションを指定すると、一部のアイテムのレンダリングが不適切なものになるため、お勧めできません。|auto、host、mesa、angle、swiftshader、off|
|`hw.gsmModem`|**GSM モデム サポート** &ndash; エミュレートされたデバイスに、GSM (Global System for Mobile Communications) テレフォニー ラジオ システムをサポートするモデムが含まれるかどうかを判別します。|yes、no|
|`hw.initialOrientation`|**最初の画面の向き** &ndash; エミュレートされたデバイスの画面の最初の向きを構成します (縦または横モード)。 縦モードの場合、画面は縦長になります。 横モードの場合、画面は横長になります。 エミュレートされたデバイスを実行するときに、デバイス プロファイルで縦と横の両方がサポートされている場合は、向きを変更できます。|portrait、landscape|
|`hw.keyboard`|**キーボード サポート** &ndash; エミュレートされたデバイスが QWERTY キーボードをサポートするかどうかを判別します。|yes、no|
|`hw.keyboard.charmap`|**キーボード charmap 名** &ndash; このデバイスのハードウェア charmap の名前。 注:システム イメージを適宜変更した場合を除き、これは常に既定値の **qwerty2** である必要があります。 この名前は起動時にカーネルに送信されます。 正しくない名前を使用すると、仮想デバイスが使用できなくなります。||
|`hw.keyboard.lid`|**キーボードの表示/非表示サポート** &ndash; キーボード サポートが有効な場合、この設定で、QWERTY キーボードを閉じる/非表示にできるか、開く/表示できるかを判別します。 hw.keyboard が false に設定されている場合、この設定は無視されます。 注: エミュレートされたデバイスの対象が API レベル 12 以上の場合、既定値は false になります。|yes、no|
|`hw.lcd.backlight`|**LCD バックライト** &ndash; エミュレートされたデバイスで LCD バックライトがシミュレートされるかどうかを判別します。|yes、no|
|`hw.lcd.density`|**LCD の密度** &ndash; エミュレートされた LCD ディスプレイの密度。密度に依存しないピクセル、または dp (dp は仮想ピクセル単位です) で測定されます。 設定が 160 dp の場合、各 dp は 1 物理ピクセルに対応します。 実行時に、Android はこの値を使用して、正しいディスプレイ レンダリングに適切なリソース/アセットを選択してスケーリングします。|120、160、240、213、320|
|`hw.lcd.depth`|**LCD の色深度** &ndash; LCD ディスプレイを駆動するためのビットマップを保持する、エミュレートされたフレームバッファの色ビット深度。 この値には 16 ビット (65,536 色表示可能) または 32 ビット (16,777,216 色と透明) を指定できます。 32 ビットを設定すると、エミュレーターの実行速度が若干低下しますが、色の精度が向上します。|16, 32|
|`hw.lcd.height`|**LCD のピクセルの高さ** &ndash; エミュレートされた LCD ディスプレイの垂直ディメンションを構成するピクセル数。||
|`hw.lcd.width`|**LCD のピクセル幅** &ndash; エミュレートされた LCD ディスプレイの水平ディメンションを構成するピクセル数。||
|`hw.mainKeys`|**ハードウェアの Back/Home キー** &ndash; エミュレートされたデバイスがハードウェアの Back および Home ナビゲーション ボタンをサポートするかどうかを判別します。 ボタンがソフトウェアにのみ実装されている場合は、この値を **yes** に設定できます。 `hw.mainKeys` が **yes** に設定されている場合、エミュレーターは画面にナビゲーション ボタンを表示しませんが、エミュレーター側のパネルを使用して、これらのボタンを "押す" ことはできます。|yes、no|
|`hw.ramSize`|**デバイスの RAM サイズ** &ndash; エミュレートされたデバイス上の物理 RAM の容量 (メガバイト単位)。 既定値は、画面のサイズまたはスキン バージョンから計算されます。 サイズを増やすことでエミュレーターの操作速度を上げることはできますが、その代わり、開発コンピューターからのリソース要求が増えます。||
|`hw.screen`|**タッチスクリーンの種類** &ndash; エミュレートされたデバイスの画面の種類を定義します。 multi-touch スクリーンでは、タッチ インターフェイスでの 2 本以上の指を追跡できます。 touch スクリーンでは、1 本の指のタッチ イベントのみを検出できます。 no-touch スクリーンではタッチ イベントは検出されません。|touch、multi-touch、no-touch|
|`hw.sdCard`|**SDCard サポート** &ndash; エミュレートされたデバイスが仮想 SD (セキュア デジタル) カードの挿入と削除をサポートするかどうかを判別します。 エミュレーターでは開発用コンピューターに格納されているマウント可能なディスク イメージを使用して、実際の SD カード デバイスのパーティションをシミュレートします (hw.sdCard.path を参照)。|yes、no|
|`sdcard.size`|**SDCard サイズ** &ndash;`hw.sdCard.path` で指定された場所で仮想 SD カード ファイルのサイズを指定します。 デバイスで使用可能です (バイト単位)。 この値が整数の場合は、バイト単位でサイズが指定されます。 値に **K**、**M**、**G** を追加することで、キロバイト、メガバイト、ギガバイト単位でサイズを指定することもできます。 最小サイズは **9 M** で、最大サイズは **1023 G** です。||
|`hw.sdCard.path`|**SDCard イメージ パス** &ndash; 開発用コンピューターで SD カード パーティション イメージ ファイルのファイル名とパスを指定します。 たとえば、Windows の場合は、このパスを **C:\sd\sdcard.img** に設定することができます。||
|`hw.sensors.magnetic_field`|**磁場センサー** &ndash; エミュレートされたデバイスが磁場センサーをサポートするかどうかを判別します。 磁場センサー (磁力計ともいう) は、3 つのセンサー軸に沿って測定されたアンビエント磁場を報告します。 コンパス読み取り値へのアクセスが必要なアプリに対して、この設定を有効にします。 たとえば、ナビゲーション アプリではこの設定を使用して、ユーザーがどの方向を向いているかを検出する場合があります。|yes、no|
|`hw.sensors.orientation`|**方向センサー** &ndash; エミュレートされたデバイスが方向センサー値を提供するかどうかを判別します。 方向センサーは、デバイスが 3 つすべての物理軸 (x、y、z) を中心に回転する角度を測定します。 方向センサーは、Android 2.2 (API レベル 8) の時点で非推奨となったことに注意してください。|yes、no|
|`hw.sensors.proximity`|**近接センサー** &ndash; エミュレートされたデバイスが近接センサーをサポートするかどうかを判別します。 このセンサーは、デバイスの表示画面を基準にオブジェクトの近接度を測定します。 通常、このセンサーは、ハンドセットがユーザーの耳に当てられているかどうかを判別するために使用されます。|yes、no|
|`hw.sensors.temperature`|**温度センサー** &ndash; エミュレートされたデバイスが温度センサーをサポートするかどうかを判別します。 このセンサーでは、摂氏 (&deg;C) でデバイスの温度を測定します。|yes、no|
|`hw.touchScreen`|**タッチスクリーン サポート** &ndash; エミュレートされたデバイスがタッチスクリーンをサポートするかどうかを判別します。 タッチ スクリーンは、スクリーン上のオブジェクトを直接操作する場合に使用されます。|yes、no|
|`hw.trackBall`|**トラックボール サポート** &ndash; エミュレートされたデバイスがトラックボールをサポートするかどうかを判別します。|yes、no|
|`hw.useext4`|**EXT4 ファイル システムのサポート** &ndash; エミュレートされたデバイスがパーティションで Linux EXT4 ファイル システムを使用するかどうかを判別します。 現在、ファイル システムの種類は自動検出されるため、このオプションは非推奨とされており、無視されます。|Ｘ|
|`kernel.newDeviceNaming`|**カーネルの新しいデバイスの名前付け** &ndash; カーネルが新しいデバイスの名前付けスキームを必要とするかどうかを指定する場合に使用します。 通常、これは Linux 3.10 カーネル以降で使用されます。 **autodetect** に設定した場合、エミュレーターは、カーネルが新しいデバイスの名前付けスキームを必要とするかどうかを自動的に検出します。|autodetect、yes、no|
|`kernel.parameters`|**カーネル パラメーター** &ndash; Linux カーネルのブート パラメーターの文字列を指定します。 既定では、この設定は空白のままになります。||
|`kernel.path`|**カーネル パス** &ndash; Linux カーネルへのパスを指定します。 このパスが指定されていない場合、エミュレーターは、エミュレーターのシステム ディレクトリで kernel-ranchu を調べます。||
|`kernel.supportsYaffs2`|**YAFFS2 パーティション サポート** &ndash; カーネルが YAFFS2 (Yet Another Flash File System 2) パーティションをサポートするかどうかを判別します。 通常、これは Linux 3.10 より前のカーネルにのみ適用されます。 **autodetect** に設定した場合、エミュレーターは、カーネルで YAFFS2 ファイル システムをマウントできるかどうかを自動的に検出します。|autodetect、yes、no|
|`skin.name`|**スキン名** &ndash; Android エミュレーター スキンの名前。 スキンは、エミュレーター ディスプレイの視覚および制御要素を定義するファイルのコレクションです。開発コンピューターでの AVD のウィンドウの外観を説明します。 スキンは画面のサイズ、ボタン、全体のデザインを説明しますが、アプリの操作には影響しません。||
|`skin.path`|**スキン パス** &ndash; skin.name で指定されたエミュレーターのスキン ファイルを含むディレクトリへのパス。このディレクトリには、hardware.ini レイアウト ファイルと、スキンの表示要素に対するイメージ ファイルが含まれます。||
|`skin.dynamic`|**スキンが動的** &ndash; スキンが動的であるかどうか。 エミュレーターが指定された幅と高さに基づいて特定のサイズのスキンを構築する場合、エミュレーター スキンは動的スキンとなります。|Ｘ|
